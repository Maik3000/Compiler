package compiler.parser;

import compiler.scanner.Scanner;
import compiler.ast.*;

import java.util.*;
import java_cup.runtime.*;
import java.io.FileWriter;
import java.io.PrintWriter;
import java.io.FileReader;
import java.io.IOException;

parser code {:
    private Scanner scanner;

    public Parser(Scanner scanner) {
        this.scanner = scanner;
    }

    public Symbol scan() throws Exception {
        return scanner.next_token();
    }

    public void syntax_error(Symbol s) {
        report_error(
            "Error de sintaxis en línea " + (s.left) + ", columna " + (s.right)
            + ". Token inesperado: " + s.value, null
        );
    }
:}

/* Terminales */
terminal CLASS, VOID;
terminal IF, ELSE, FOR, WHILE, RETURN, BREAK, CONTINUE, CALLOUT, NEW;
terminal COMMA, SEMI;
terminal ASSIGN, UMINUS, PLUS_ASSIGN, MINUS_ASSIGN;
terminal PLUS, MINUS, TIMES, DIVIDE, MOD;
terminal EQ, NEQ, LT, GT, LE, GE; 
terminal INT, BOOLEAN, CHAR;
terminal AND, OR, NOT;
terminal TRUE, FALSE;
terminal LBRACE, RBRACE, LPAREN, RPAREN, LBRACKET, RBRACKET;
terminal Integer INT_LITERAL;
terminal String ID, STRING_LITERAL, CHAR_LITERAL;

/* No terminales */
non terminal ProgramNode programNode;
non terminal StatementNode forUpdateStmtNode;
non terminal List<VarDeclaration> varDeclListNode;
non terminal String assignOperatorNode;
non terminal List<CalloutArgument> calloutArgListOptNode, calloutArgListNode;
non terminal BlockNode blockNode;
non terminal List<StatementNode> stmtListNode;
non terminal List<ClassMember> classMemberListNode;
non terminal AssignmentExpression assignExprNode;
non terminal List<ExpressionNode> exprListNode, exprListOptNode;
non terminal List<Parameter> paramListNode;
non terminal MethodCallNode methodCallNode;
non terminal IntegerLiteral intLiteralNode;
non terminal VariableNode optionalArrayIdNode;
non terminal ExpressionNode exprNode, exprOptNode;
non terminal List<VarDeclaration> varDeclNode;
non terminal CharacterLiteral charLiteralNode;
non terminal StatementNode stmtNode;
non terminal BooleanLiteral boolLiteralNode;
non terminal List<VariableNode> idArrayListNode;
non terminal String binaryOperatorNode, arithmeticOperatorNode, relationalOperatorNode, equalityOperatorNode, conditionalOperatorNode;
non terminal DataTypeNode typeNode;
non terminal StatementNode forInitExprNode;
non terminal ExpressionNode assignOptNode;
non terminal CalloutArgument calloutArgNode;
non terminal LocationNode locationNode;
non terminal Parameter paramNode;
non terminal LiteralNode literalNode;
non terminal String methodNameNode;
non terminal ClassMember classMemberNode;

/* Precedencias */
precedence left OR;
precedence left AND;
precedence nonassoc EQ, NEQ;
precedence nonassoc LT, GT, LE, GE;
precedence left PLUS, MINUS;
precedence left TIMES, DIVIDE, MOD;
precedence right UMINUS;
precedence right NOT;

/* Símbolo inicial */
start with programNode;

/* Reglas de la gramática */

programNode ::= CLASS ID:name LBRACE classMemberListNode:members RBRACE
                {: RESULT = new ProgramNode(name, members); :};

classMemberListNode ::= classMemberListNode:members classMemberNode:member
                         {: members.add(member); RESULT = members; :}
                      | /* vacío */
                         {: RESULT = new ArrayList<>(); :};

classMemberNode ::= typeNode:type idArrayListNode:variables SEMI
                     {:
                         List<VarDeclaration> members = new ArrayList<>();
                         for (VariableNode var : variables) {
                             members.add(new VarDeclaration(type, var.getName(), var.isArray(), null));
                         }
                         RESULT = new MultipleVarDeclaration(members);
                     :}
                  | VOID ID:name LPAREN paramListNode:params RPAREN blockNode:block
                     {: RESULT = new MethodDeclaration(new VoidTypeNode(), name, params, block); :}
                  | typeNode:type ID:name LPAREN paramListNode:params RPAREN blockNode:block
                     {: RESULT = new MethodDeclaration(type, name, params, block); :};

optionalArrayIdNode ::= ID:name
                         {: RESULT = new VariableNode(name, false); :}
                      | ID:name LBRACKET RBRACKET
                         {: RESULT = new VariableNode(name, true); :};

assignOptNode ::= ASSIGN exprNode:expr
                   {: RESULT = expr; :}
                | /* vacío */
                   {: RESULT = null; :};

paramListNode ::= paramListNode:params COMMA paramNode:param
                   {: params.add(param); RESULT = params; :}
                | paramNode:param
                   {:
                       List<Parameter> params = new ArrayList<>();
                       params.add(param);
                       RESULT = params;
                   :}
                | /* vacío */
                   {: RESULT = new ArrayList<>(); :};

paramNode ::= typeNode:type optionalArrayIdNode:var
               {: RESULT = new Parameter(type, var.getName(), var.isArray()); :};

blockNode ::= LBRACE varDeclListNode:varDecls stmtListNode:stmts RBRACE
               {: RESULT = new BlockNode(varDecls, stmts); :};

varDeclListNode ::= varDeclListNode:varDecls varDeclNode:varDecl
                     {: varDecls.addAll(varDecl); RESULT = varDecls; :}
                  | /* vacío */
                     {: RESULT = new ArrayList<>(); :};

varDeclNode ::= typeNode:type idArrayListNode:variables assignOptNode:assignOpt SEMI
                 {:
                     List<VarDeclaration> declarations = new ArrayList<>();
                     for (VariableNode var : variables) {
                         declarations.add(new VarDeclaration(type, var.getName(), var.isArray(), assignOpt));
                     }
                     RESULT = declarations;
                 :};

idArrayListNode ::= idArrayListNode:variables COMMA optionalArrayIdNode:var
                     {: variables.add(var); RESULT = variables; :}
                  | optionalArrayIdNode:var
                     {:
                         List<VariableNode> variables = new ArrayList<>();
                         variables.add(var);
                         RESULT = variables;
                     :};

stmtListNode ::= stmtListNode:stmts stmtNode:stmt
                  {: stmts.add(stmt); RESULT = stmts; :}
               | /* vacío */
                  {: RESULT = new ArrayList<>(); :};

stmtNode ::= locationNode:loc assignOperatorNode:op exprNode:expr SEMI
              {: RESULT = new AssignmentStatement(loc, op, expr); :}
           | methodCallNode:methodCall SEMI
              {: RESULT = new MethodCallStatement(methodCall); :}
           | IF LPAREN exprNode:cond RPAREN blockNode:thenBlock ELSE blockNode:elseBlock
              {: RESULT = new IfStatement(cond, thenBlock, elseBlock); :}
           | IF LPAREN exprNode:cond RPAREN blockNode:thenBlock
              {: RESULT = new IfStatement(cond, thenBlock, null); :}
           | WHILE LPAREN exprNode:cond RPAREN blockNode:bodyBlock
              {: RESULT = new WhileStatement(cond, bodyBlock); :}
           | FOR LPAREN forInitExprNode:initExpr SEMI exprOptNode:cond SEMI forUpdateStmtNode:updateStmt RPAREN blockNode:bodyBlock
              {: RESULT = new ForStatement(initExpr, cond, updateStmt, bodyBlock); :}
           | RETURN exprOptNode:exprOpt SEMI
              {: RESULT = new ReturnStatement(exprOpt); :}
           | BREAK SEMI
              {: RESULT = new BreakStatement(); :}
           | CONTINUE SEMI
              {: RESULT = new ContinueStatement(); :}
           | blockNode:block
              {: RESULT = block; :};

forInitExprNode ::= typeNode:type optionalArrayIdNode:var assignOperatorNode:op exprNode:expr
                     {:
                         VarDeclaration varDecl = new VarDeclaration(type, var.getName(), var.isArray(), null);
                         RESULT = new VarDeclarationStatement(varDecl, expr);
                     :}
                  | assignExprNode:assignExpr
                     {: RESULT = new ExpressionStatement(assignExpr); :}
                  | /* vacío */
                     {: RESULT = null; :};

exprOptNode ::= exprNode:expr
                 {: RESULT = expr; :}
              | /* vacío */
                 {: RESULT = null; :};

forUpdateStmtNode ::= assignExprNode:assignExpr
                       {: RESULT = new ExpressionStatement(assignExpr); :}
                    | exprNode:expr
                       {: RESULT = new ExpressionStatement(expr); :}
                    | /* vacío */
                       {: RESULT = null; :};

assignExprNode ::= locationNode:loc assignOperatorNode:op exprNode:expr
                    {: RESULT = new AssignmentExpression(loc, op, expr); :};

assignOperatorNode ::= ASSIGN
                        {: RESULT = "="; :}
                     | PLUS_ASSIGN
                        {: RESULT = "+="; :}
                     | MINUS_ASSIGN
                        {: RESULT = "-="; :};

locationNode ::= ID:name
                  {: RESULT = new VariableLocation(name); :}
               | ID:name LBRACKET exprNode:expr RBRACKET
                  {: RESULT = new ArrayLocation(name, expr); :};

methodCallNode ::= methodNameNode:name LPAREN exprListOptNode:args RPAREN
                    {: RESULT = new NormalMethodCallNode(name, args); :}
                 | CALLOUT LPAREN STRING_LITERAL:strLit calloutArgListOptNode:args RPAREN
                    {: RESULT = new CalloutCallNode(strLit, args); :};

methodNameNode ::= ID:name
                    {: RESULT = name; :};

exprListOptNode ::= exprListNode:exprList
                     {: RESULT = exprList; :}
                  | /* vacío */
                     {: RESULT = new ArrayList<>(); :};

exprListNode ::= exprListNode:exprs COMMA exprNode:expr
                  {: exprs.add(expr); RESULT = exprs; :}
               | exprNode:expr
                  {:
                      List<ExpressionNode> exprs = new ArrayList<>();
                      exprs.add(expr);
                      RESULT = exprs;
                  :};

calloutArgListOptNode ::= COMMA calloutArgListNode:args
                           {: RESULT = args; :}
                        | /* vacío */
                           {: RESULT = new ArrayList<>(); :};

calloutArgListNode ::= calloutArgListNode:args COMMA calloutArgNode:arg
                        {: args.add(arg); RESULT = args; :}
                     | calloutArgNode:arg
                        {:
                            List<CalloutArgument> args = new ArrayList<>();
                            args.add(arg);
                            RESULT = args;
                        :};

calloutArgNode ::= exprNode:expr
                    {: RESULT = new CalloutArgumentExpression(expr); :}
                 | STRING_LITERAL:strLit
                    {: RESULT = new CalloutArgumentString(strLit); :};

exprNode ::= locationNode:loc
              {: RESULT = loc; :}
           | methodCallNode:methodCall
              {: RESULT = methodCall; :}
           | literalNode:lit
              {: RESULT = lit; :}
           | exprNode:leftExpr binaryOperatorNode:op exprNode:rightExpr
              {: RESULT = new BinaryExpression(leftExpr, op, rightExpr); :}
           | MINUS exprNode:expr
              {: RESULT = new UnaryExpression("-", expr); :} %prec UMINUS
           | NOT exprNode:expr
              {: RESULT = new UnaryExpression("!", expr); :}
           | NEW typeNode:type LBRACKET exprNode:expr RBRACKET
              {: RESULT = new NewArrayExpression(type, expr); :}
           | LPAREN exprNode:expr RPAREN
              {: RESULT = expr; :};

binaryOperatorNode ::= arithmeticOperatorNode:op
                        {: RESULT = op; :}
                     | relationalOperatorNode:op
                        {: RESULT = op; :}
                     | equalityOperatorNode:op
                        {: RESULT = op; :}
                     | conditionalOperatorNode:op
                        {: RESULT = op; :};

arithmeticOperatorNode ::= PLUS
                            {: RESULT = "+"; :}
                         | MINUS
                            {: RESULT = "-"; :}
                         | TIMES
                            {: RESULT = "*"; :}
                         | DIVIDE
                            {: RESULT = "/"; :}
                         | MOD
                            {: RESULT = "%"; :};

relationalOperatorNode ::= LT
                            {: RESULT = "<"; :}
                         | GT
                            {: RESULT = ">"; :}
                         | LE
                            {: RESULT = "<="; :}
                         | GE
                            {: RESULT = ">="; :};

equalityOperatorNode ::= EQ
                          {: RESULT = "=="; :}
                       | NEQ
                          {: RESULT = "!="; :};

conditionalOperatorNode ::= AND
                             {: RESULT = "&&"; :}
                          | OR
                             {: RESULT = "||"; :};

literalNode ::= intLiteralNode:intLit
                 {: RESULT = intLit; :}
              | charLiteralNode:charLit
                 {: RESULT = charLit; :}
              | boolLiteralNode:boolLit
                 {: RESULT = boolLit; :};

intLiteralNode ::= INT_LITERAL:value
                    {: RESULT = new IntegerLiteral(value); :};

charLiteralNode ::= CHAR_LITERAL:value
                     {: RESULT = new CharacterLiteral(value.charAt(0)); :};

/* Literales booleanos */
boolLiteralNode ::= TRUE
                     {: RESULT = new BooleanLiteral(true); :}
                  | FALSE
                     {: RESULT = new BooleanLiteral(false); :};

/* Tipos de dato */
typeNode ::= INT
              {: RESULT = new IntegerTypeNode(); :}
           | BOOLEAN
              {: RESULT = new BooleanTypeNode(); :}
           | CHAR
              {: RESULT = new CharacterTypeNode(); :};